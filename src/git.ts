import type { Config, ExistingPr, UpdateCandidate, VersionReleaseNote } from './types'
import { formatReleaseNotes } from './registry'

// ---------------------------------------------------------------------------
// Shell execution
// ---------------------------------------------------------------------------

export async function exec({
  command,
  cwd
}: {
  command: string[]
  cwd: string
}): Promise<{ stdout: string; stderr: string; exitCode: number }> {
  const proc = Bun.spawn(command, {
    cwd,
    stdout: 'pipe',
    stderr: 'pipe',
    env: process.env
  })

  const [stdout, stderr] = await Promise.all([new Response(proc.stdout).text(), new Response(proc.stderr).text()])
  const exitCode = await proc.exited

  if (exitCode !== 0) {
    console.error(`  Command failed: ${command.join(' ')}`)
    if (stderr.trim()) console.error(`  stderr: ${stderr.trim()}`)
  }

  return { stdout: stdout.trim(), stderr: stderr.trim(), exitCode }
}

// ---------------------------------------------------------------------------
// Install command
// ---------------------------------------------------------------------------

function getInstallCommand({ packageManager }: { packageManager: Config['packageManager'] }): string[] {
  switch (packageManager) {
    case 'bun': return ['bun', 'install']
    case 'npm': return ['npm', 'install']
    case 'pnpm': return ['pnpm', 'install']
    case 'yarn': return ['yarn', 'install']
  }
}

// ---------------------------------------------------------------------------
// PR body
// ---------------------------------------------------------------------------

export function buildPrBody({
  updates,
  releaseNotes
}: {
  updates: UpdateCandidate[]
  releaseNotes: Map<string, VersionReleaseNote[]>
}): string {
  const sorted = [...updates].sort((a, b) => a.name.localeCompare(b.name))

  const lines = [
    '## Dependency Updates',
    '',
    '| Package | From | To | Type |',
    '| --- | --- | --- | --- |',
    ...sorted.map((u) => `| \`${u.name}\` | ${u.currentVersion} | ${u.latestVersion} | ${u.changeType} |`)
  ]

  lines.push(...formatReleaseNotes({ updates, releaseNotes }))
  lines.push('---', '*This PR was auto-generated by [catalog-update-action](https://github.com/brandhaug/catalog-update-action).*')

  return lines.join('\n')
}

export function buildCatalogValue({ update }: { update: UpdateCandidate }): string {
  if (update.isAlias) {
    return `npm:${update.aliasName}@${update.latestVersion}`
  }
  return update.hasCaret ? `^${update.latestVersion}` : update.latestVersion
}

// ---------------------------------------------------------------------------
// Existing PRs
// ---------------------------------------------------------------------------

export async function getExistingPrs({
  cwd,
  branchPrefix
}: {
  cwd: string
  branchPrefix: string
}): Promise<ExistingPr[]> {
  const { stdout } = await exec({
    command: [
      'gh', 'pr', 'list',
      '--state', 'open',
      '--search', `head:${branchPrefix}`,
      '--json', 'headRefName,number,mergeable,title',
      '--limit', '100'
    ],
    cwd
  })

  try {
    const prs = JSON.parse(stdout || '[]') as ExistingPr[]
    return prs.filter((pr) => pr.headRefName.startsWith(`${branchPrefix}/`))
  } catch {
    return []
  }
}

export async function hasNonBotCommits({ pr, cwd }: { pr: ExistingPr; cwd: string }): Promise<boolean> {
  const { stdout, exitCode } = await exec({
    command: ['gh', 'pr', 'view', String(pr.number), '--json', 'commits'],
    cwd
  })

  if (exitCode !== 0) return true

  try {
    const data = JSON.parse(stdout) as { commits: Array<{ authors: Array<{ login: string }> }> }
    return data.commits.some((commit) => commit.authors.some((author) => author.login !== 'github-actions[bot]'))
  } catch {
    return true
  }
}

export async function resolveMergeableState({ pr, cwd }: { pr: ExistingPr; cwd: string }): Promise<ExistingPr['mergeable']> {
  if (pr.mergeable !== 'UNKNOWN') return pr.mergeable

  console.log(`  PR #${pr.number} has UNKNOWN mergeable state, retrying in 5s...`)
  await Bun.sleep(5000)

  const { stdout, exitCode } = await exec({
    command: ['gh', 'pr', 'view', String(pr.number), '--json', 'mergeable'],
    cwd
  })

  if (exitCode !== 0) return 'UNKNOWN'

  try {
    const data = JSON.parse(stdout) as { mergeable: ExistingPr['mergeable'] }
    return data.mergeable
  } catch {
    return 'UNKNOWN'
  }
}

// ---------------------------------------------------------------------------
// Branch operations
// ---------------------------------------------------------------------------

export async function isBranchBehindDefault({
  branch,
  defaultBranch,
  cwd
}: {
  branch: string
  defaultBranch: string
  cwd: string
}): Promise<boolean> {
  const { stdout, exitCode } = await exec({
    command: ['git', 'rev-list', '--count', `origin/${branch}..origin/${defaultBranch}`],
    cwd
  })

  if (exitCode !== 0) return true
  return Number(stdout) > 0
}

export async function isBranchOutdated({
  branch,
  updates,
  cwd
}: {
  branch: string
  updates: UpdateCandidate[]
  cwd: string
}): Promise<boolean> {
  const { stdout, exitCode } = await exec({
    command: ['git', 'show', `origin/${branch}:package.json`],
    cwd
  })

  if (exitCode !== 0) return true

  try {
    const branchPackageJson = JSON.parse(stdout) as { catalog?: Record<string, string> }
    const branchCatalog = branchPackageJson.catalog
    if (!branchCatalog) return true

    for (const update of updates) {
      const expected = buildCatalogValue({ update })
      if (branchCatalog[update.name] !== expected) return true
    }

    return false
  } catch {
    return true
  }
}

async function returnToDefault({ defaultBranch, cwd }: { defaultBranch: string; cwd: string }): Promise<void> {
  await exec({ command: ['git', 'checkout', '--', '.'], cwd })
  const { exitCode } = await exec({ command: ['git', 'checkout', defaultBranch], cwd })
  if (exitCode !== 0) {
    throw new Error(`Fatal: failed to return to ${defaultBranch} branch. Aborting remaining groups.`)
  }
}

// ---------------------------------------------------------------------------
// Branch update + PR creation
// ---------------------------------------------------------------------------

export async function updateGroupBranch({
  groupName,
  updates,
  config,
  cwd,
  packageJsonPath,
  releaseNotes
}: {
  groupName: string
  updates: UpdateCandidate[]
  config: Config
  cwd: string
  packageJsonPath: string
  releaseNotes: Map<string, VersionReleaseNote[]>
}): Promise<{ success: boolean; title: string; body: string }> {
  const branch = `${config.branchPrefix}/${groupName}`
  const first = updates[0]
  const title =
    first && updates.length === 1
      ? `chore(deps): bump ${first.name} from ${first.currentVersion} to ${first.latestVersion}`
      : `chore(deps): bump ${groupName} dependencies`
  const body = buildPrBody({ updates, releaseNotes })
  const fail = { success: false, title, body }

  const checkoutResult = await exec({
    command: ['git', 'checkout', '-B', branch, `origin/${config.defaultBranch}`],
    cwd
  })
  if (checkoutResult.exitCode !== 0) return fail

  const packageJson = await Bun.file(packageJsonPath).json()
  const catalog = packageJson.catalog as Record<string, string> | undefined

  if (!catalog || typeof catalog !== 'object') {
    console.error(`  No valid catalog found in package.json for group "${groupName}"`)
    await returnToDefault({ defaultBranch: config.defaultBranch, cwd })
    return fail
  }

  for (const update of updates) {
    catalog[update.name] = buildCatalogValue({ update })
  }

  await Bun.write(packageJsonPath, `${JSON.stringify(packageJson, null, 2)}\n`)

  console.log('  Running install...')
  const installResult = await exec({ command: getInstallCommand({ packageManager: config.packageManager }), cwd })
  if (installResult.exitCode !== 0) {
    console.error(`  Failed to run install for group "${groupName}"`)
    await returnToDefault({ defaultBranch: config.defaultBranch, cwd })
    return fail
  }

  const { stdout: diffFiles } = await exec({ command: ['git', 'diff', '--name-only'], cwd })
  const lockfileNames = new Set(['package.json', 'bun.lock', 'package-lock.json', 'pnpm-lock.yaml', 'yarn.lock'])
  const unexpectedFiles = diffFiles.split('\n').filter((f) => f && !lockfileNames.has(f))
  if (unexpectedFiles.length > 0) {
    console.warn(`  Warning: install modified unexpected files: ${unexpectedFiles.join(', ')}`)
  }

  const filesToStage = ['package.json', ...diffFiles.split('\n').filter(Boolean)]
  await exec({ command: ['git', 'add', ...filesToStage], cwd })

  const commitResult = await exec({ command: ['git', 'commit', '--no-verify', '-m', title], cwd })
  if (commitResult.exitCode !== 0) {
    console.error(`  Failed to commit for group "${groupName}"`)
    await returnToDefault({ defaultBranch: config.defaultBranch, cwd })
    return fail
  }

  const pushResult = await exec({
    command: ['git', 'push', `--force-with-lease=${branch}`, 'origin', branch],
    cwd
  })
  if (pushResult.exitCode !== 0) {
    console.error(`  Failed to push branch "${branch}"`)
    await returnToDefault({ defaultBranch: config.defaultBranch, cwd })
    return fail
  }

  await returnToDefault({ defaultBranch: config.defaultBranch, cwd })
  return { success: true, title, body }
}

export async function createGroupPr({
  groupName,
  updates,
  config,
  cwd,
  packageJsonPath,
  releaseNotes
}: {
  groupName: string
  updates: UpdateCandidate[]
  config: Config
  cwd: string
  packageJsonPath: string
  releaseNotes: Map<string, VersionReleaseNote[]>
}): Promise<boolean> {
  const branch = `${config.branchPrefix}/${groupName}`
  console.log(`\n  Creating PR for group "${groupName}" (${updates.length} packages)`)

  const result = await updateGroupBranch({ groupName, updates, config, cwd, packageJsonPath, releaseNotes })
  if (!result.success) return false

  const prResult = await exec({
    command: [
      'gh', 'pr', 'create',
      '--base', config.defaultBranch,
      '--head', branch,
      '--title', result.title,
      '--body', result.body
    ],
    cwd
  })

  if (prResult.exitCode === 0) {
    console.log(`  PR created: ${prResult.stdout}`)
  } else {
    console.error(`  Failed to create PR for group "${groupName}"`)
    if (prResult.stderr?.includes('not permitted to create or approve pull requests')) {
      console.error('  Enable "Allow GitHub Actions to create and approve pull requests" in repository Settings > Actions > General > Workflow permissions.')
      console.error('  If the checkbox is disabled, an organization admin must first enable it in Organization Settings > Actions > General > Workflow permissions.')
    }
  }

  return prResult.exitCode === 0
}

export async function syncExistingPrs({
  existingPrs,
  groups,
  config,
  cwd,
  packageJsonPath,
  releaseNotes
}: {
  existingPrs: ExistingPr[]
  groups: Map<string, UpdateCandidate[]>
  config: Config
  cwd: string
  packageJsonPath: string
  releaseNotes: Map<string, VersionReleaseNote[]>
}): Promise<{ closedCount: number; rebuiltCount: number }> {
  if (existingPrs.length === 0) {
    console.log('  No existing PRs to sync')
    return { closedCount: 0, rebuiltCount: 0 }
  }

  console.log(`  Syncing ${existingPrs.length} existing PR(s)`)

  const nonBotResults = new Map<number, boolean>()
  await Promise.all(
    existingPrs.map(async (pr) => {
      nonBotResults.set(pr.number, await hasNonBotCommits({ pr, cwd }))
    })
  )

  let closedCount = 0
  let rebuiltCount = 0

  for (const pr of existingPrs) {
    if (nonBotResults.get(pr.number)) {
      console.log(`  Skipping PR #${pr.number} — has non-bot commits`)
      continue
    }

    const groupName = pr.headRefName.slice(`${config.branchPrefix}/`.length)
    const updates = groups.get(groupName)

    if (!updates || updates.length === 0) {
      console.log(`  Closing stale PR #${pr.number} — packages in group "${groupName}" are already up to date`)
      const closeResult = await exec({
        command: [
          'gh', 'pr', 'close', String(pr.number),
          '--comment', 'Closing: all packages in this group are already up to date.'
        ],
        cwd
      })
      if (closeResult.exitCode === 0) {
        closedCount++
      }
      continue
    }

    const mergeable = await resolveMergeableState({ pr, cwd })
    const isConflicting = mergeable === 'CONFLICTING'
    const behindDefault =
      !isConflicting && (await isBranchBehindDefault({ branch: pr.headRefName, defaultBranch: config.defaultBranch, cwd }))
    const hasCatalogChanges =
      !isConflicting && !behindDefault && (await isBranchOutdated({ branch: pr.headRefName, updates, cwd }))

    if (!isConflicting && !behindDefault && !hasCatalogChanges) {
      console.log(`  PR #${pr.number} (${groupName}) is up to date`)
      continue
    }

    let reason = 'outdated catalog entries'
    if (isConflicting) reason = 'conflicting'
    else if (behindDefault) reason = `behind ${config.defaultBranch}`
    console.log(`\n  Rebuilding PR #${pr.number} (${groupName}) — ${reason}`)

    try {
      const result = await updateGroupBranch({ groupName, updates, config, cwd, packageJsonPath, releaseNotes })
      if (!result.success) {
        console.error(`  Failed to rebuild PR #${pr.number} (${groupName})`)
        continue
      }

      const editResult = await exec({
        command: ['gh', 'pr', 'edit', String(pr.number), '--title', result.title, '--body', result.body],
        cwd
      })

      if (editResult.exitCode !== 0) {
        console.warn(`  Warning: Failed to update title/body for PR #${pr.number}, but branch was rebuilt`)
      }

      console.log(`  Successfully rebuilt PR #${pr.number} (${groupName})`)
      rebuiltCount++
    } catch (error: unknown) {
      console.error(`  Error rebuilding PR #${pr.number} (${groupName}): ${String(error)}`)
    }
  }

  return { closedCount, rebuiltCount }
}
